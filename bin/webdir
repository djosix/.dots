#!/usr/bin/env python3
# Author: djosix
# License: MIT

# python3 -m pip install -U flask flask_httpauth werkzeug cryptography gunicorn
# autopep8 --max-line-length 130 -i `which webdir`

import json
import re
import os
import sys
import random
import string
import enum
import base64
import traceback
import textwrap
from datetime import datetime, timedelta
from typing import List, NamedTuple, Union, Optional, Tuple
from argparse import ArgumentParser
from contextlib import suppress
from dataclasses import dataclass


def exit_with_package_import_error(e: ImportError):
    assert isinstance(e, ImportError)
    REQUIRED_PACKAGES = [
        'flask',
        'flask_httpauth',
        'werkzeug',
        'cryptography',
        'gunicorn',
        'markupsafe',
    ]
    print(traceback.format_exc())
    print('You must install all the required packages:')
    print('  {} -m pip install {}'.format(sys.executable, ' '.join(REQUIRED_PACKAGES)))
    sys.exit(1)


try:
    from flask import (
        Flask, request, abort, redirect, make_response, jsonify
    )
    from flask.helpers import send_file
    from flask_httpauth import HTTPBasicAuth
    from werkzeug.utils import secure_filename
    from markupsafe import escape
except ImportError as e:
    exit_with_package_import_error(e)


class Constant:
    STYLE = textwrap.dedent('''
    * {
        font-family: monospace;
    }
    body,div,span,table,tr,tbody,thead,td,th {
        padding: 0px;
        margin: 0px;
        border: 0px;
    }
    .container {
        padding-top: 1em;
        padding-left: 1em;
        padding-right: 1em;
    }
    .section {
        padding-bottom: 1em;
    }
    .table-header-link {
        font-weight: bold;
        // font-style: italic;
    }
    .table-cell-checkbox {
        padding: 0.25em 0.25em;
    }
    .table-cell-normal {
        padding: 0.25em 0.5em;
    }
    .table-cell-icon {
        padding-left: 0.5em;
    }
    .menu-item {
        display: inline-block;
        margin-right: 0.5em;
    }
    .table-header {
        border-bottom: 1px solid black;
    }
    .table {
        border-collapse: collapse;
        display: block;
        white-space: nowrap;
    }
    .hidden {
        display: none;
    }
    .mark {
        background-color: yellow;
    }
    .table-header-link[data-order=desc]::after {
        content: "-";
    }
    .table-header-link[data-order=asc]::after {
        content: "+";
    }
    .table-row:hover {
        background-color: #F0F0F0;
    }
    ''')

    SCRIPT = textwrap.dedent('''
    function refreshFilterResult(filterRegex) {
        let regex;
        try {
            regex = new RegExp(filterRegex, 'i');
        } catch (e) {
            regex = new RegExp(/.*/);
        }
        document.querySelectorAll('.table-row').forEach(function (el) {
            let entryName = el.getAttribute('data-sort-name');
            if (regex.test(entryName)) {
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        });
    }

    document.querySelector('input.name-filter').addEventListener('input', function (e) {
        e.preventDefault();
        refreshFilterResult(e.target.value);
    });

    function refreshButtons() {
        let checkboxes = [...document.querySelectorAll('input.table-row-checkbox')];
        let selected = checkboxes.filter(el => el.checked);
        let uploadButton = document.querySelector('button#upload');
        if (uploadButton) {
            if (selected.length > 0 || !writable && modifiable) {
                uploadButton.setAttribute('disabled', '');
            } else {
                uploadButton.removeAttribute('disabled');
            }
        }
        let deleteButton = document.querySelector('button#delete');
        if (deleteButton) {
            if (selected.length > 0 && writable && modifiable) {
                deleteButton.removeAttribute('disabled');
            } else {
                deleteButton.setAttribute('disabled', '');
            }
        }
        let newFolderButton = document.querySelector('button#newfolder');
        if (newFolderButton && !writable) {
            newFolderButton.setAttribute('disabled', '');
        }
    }

    function refreshCheckboxState(changedCheckBox) {
        let checkboxAll = document.querySelector('input.table-row-checkbox-all');
        let checkboxes = document.querySelectorAll('input.table-row-checkbox');
        if (changedCheckBox === checkboxAll) {
            checkboxes.forEach(function (checkbox) {
                checkbox.checked = checkboxAll.checked;
            });
        } else {
            let allChecked = true;
            for (let checkbox of checkboxes) {
                if (!checkbox.checked) {
                    allChecked = false;
                    break;
                }
            }
            checkboxAll.checked = allChecked;
        }
    }

    document.querySelectorAll('input.table-row-checkbox-all,input.table-row-checkbox').forEach(function (checkbox) {
        checkbox.addEventListener('input', function (e) {
            e.preventDefault();
            refreshCheckboxState(e.target);
            refreshButtons();
        });
    });

    function refreshTableRowOrder(criterion, sign) {
        criterion ||= x => x.getAttribute('data-sort-order');
        sign = Math.sign(sign || 1);
        let table = document.querySelector('table.table');
        let rows = [...table.querySelectorAll('.table-row')];
        console.log(rows);
        rows.sort((a, b) => (criterion(a) > criterion(b) ? sign : -sign));
        for (let el of rows) {
            el.remove();
            table.appendChild(el);
        }
    }

    function createUploadForm(action = '') {
        let form = document.createElement('form');
        form.setAttribute('action', action);
        form.setAttribute('method', 'post');
        form.setAttribute('enctype', 'multipart/form-data');
        form.style.display = 'none';

        form.appendChild(function () {
            let action = document.createElement('input');
            action.setAttribute('type', 'hidden');
            action.setAttribute('name', 'action');
            action.setAttribute('value', 'upload');
            return action;
        }());

        let file = document.createElement('input');
        file.setAttribute('type', 'file');
        file.setAttribute('name', 'file');
        file.setAttribute('multiple', '');
        file.addEventListener('change', function fileChangeListener(e) {
            e.target.removeEventListener('change', fileChangeListener);
            if (e.target.files.length > 0) {
                document.body.appendChild(form);
                form.submit();
            }
        });
        form.appendChild(file);

        return { form, file };
    }

    function uploadFiles(action = '') {
        let obj = createUploadForm(action);
        obj.file.click();
    }

    let uploadButton = document.querySelector('button#upload');
    if (uploadButton) {
        uploadButton.addEventListener('click', function (e) {
            uploadFiles();
        });
    }

    document.body.addEventListener('dragover', function (e) {
        e.preventDefault();
    });

    document.body.addEventListener('drop', function(e) {
        console.log('test');
        e.preventDefault();
        if (!modifiable) {
            alert('Modification is disabled.');
        } else if (!writable) {
            alert('Current directory is not writable.');
        } else {
            let obj = createUploadForm();
            obj.file.files = e.dataTransfer.files;
            obj.file.dispatchEvent(new Event('change'));
        }
    }, true);

    function deleteFiles(action = '') {
        let form = document.createElement('form');
        form.setAttribute('action', action);
        form.setAttribute('method', 'post');
        form.style.display = 'none';

        form.appendChild(function () {
            let action = document.createElement('input');
            action.setAttribute('type', 'hidden');
            action.setAttribute('name', 'action');
            action.setAttribute('value', 'delete');
            return action;
        }());

        let selected = [...document.querySelectorAll('input.table-row-checkbox')].filter(el => el.checked);

        if (selected.length > 0) {
            let result = confirm('Are you sure to delete these entries?');
            if (!result) {
                return;
            }
        } else if (selected.length == 0) {
            return;
        }

        for (let el of selected) {
            let input = document.createElement('input');
            input.setAttribute('type', 'hidden');
            input.setAttribute('name', 'name');
            input.setAttribute('value', el.getAttribute('data-entry-name'));
            form.appendChild(input);
        }

        document.body.appendChild(form);
        form.submit();
    }

    function createFolder(action='') {
        let name = prompt('Please specify a folder name:');
        if (!name) {
            return;
        }
        let invalidChars = /[~!@#$%^&\\*\\(\\)\\+\\{\\}\\|:"<>\\?`\\[\\]\\\\=',\\/]/;
        let matchedInvalidChars = invalidChars.exec(name);
        if (matchedInvalidChars) {
            matchedInvalidChars = [...matchedInvalidChars];
            matchedInvalidChars = matchedInvalidChars.map(c => `(${c})`);
            let formatted = matchedInvalidChars.join(', ');
            alert(`Name contains invalid characters: ${formatted}`);
            return;
        }
        let escapedName = CSS.escape(name);
        if (document.querySelector(`[data-entry-name=${escapedName}]`)) {
            alert(`Entry [${name}] already exists!`);
            return;
        }

        let form = document.createElement('form');
        form.setAttribute('action', action);
        form.setAttribute('method', 'post');
        form.style.display = 'none';
        form.appendChild(function () {
            let action = document.createElement('input');
            action.setAttribute('type', 'hidden');
            action.setAttribute('name', 'action');
            action.setAttribute('value', 'new_folder');
            return action;
        }());
        form.appendChild(function () {
            let action = document.createElement('input');
            action.setAttribute('type', 'hidden');
            action.setAttribute('name', 'name');
            action.setAttribute('value', name);
            return action;
        }());
        document.body.appendChild(form);
        form.submit();
    }

    let deleteButton = document.querySelector('button#delete');
    if (deleteButton) {
        deleteButton.addEventListener('click', function (e) {
            deleteFiles();
        })
    }

    let newFolderButton = document.querySelector('button#newfolder');
    if (newFolderButton) {
        newFolderButton.addEventListener('click', function (e) {
            createFolder();
        });
    }

    refreshButtons();

    const sortCriteria = {
        name: row => row.getAttribute('data-sort-name'),
        type: row => row.getAttribute('data-sort-type'),
        ctime: row => row.getAttribute('data-sort-ctime'),
        mtime: row => row.getAttribute('data-sort-mtime'),
        atime: row => row.getAttribute('data-sort-atime'),
        size: row => row.getAttribute('data-sort-size'),
        order: row => row.getAttribute('data-sort-order'),
    };

    document.querySelectorAll('.table-header-link').forEach(function (link) {
        link.addEventListener('click', function (e) {
            e.preventDefault();

            document.querySelectorAll('.table-header-link').forEach(function (otherLink) {
                if (link != otherLink) {
                    otherLink.setAttribute('data-order', '');
                }
            });

            let criterionKey = link.getAttribute('data-sort-by');
            let order = link.getAttribute('data-order');
            let criterion;
            let sortSign;

            if (!order) {
                order = 'asc';
                criterion = sortCriteria[criterionKey] || sortCriteria.order;
                sortSign = 1;
            } else if (order === 'asc') {
                order = 'desc';
                criterion = sortCriteria[criterionKey] || sortCriteria.order;
                sortSign = -1;
            } else if (order === 'desc') {
                order = '';
                criterion = sortCriteria.order;
                sortSign = 1;
            }

            console.log(criterion);

            link.setAttribute('data-order', order);
            refreshTableRowOrder(criterion, sortSign);
        });
    });

    if (location.hash === '#recent') {
        console.log(123);
        let a = document.querySelector('[data-sort-by=ctime]');
        a.click();
        a.click();
        location.hash = '';
    }
    ''')

    SVG_DATA_URI_PREFIX = 'data:image/svg+xml;base64,'

    ICON_SVG_DOCUMENT = (
        '<svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="32px" height="32px">'
        '<path d="M 4.5 2 C 3.675781 2 3 2.675781 3 3.5 L 3 12.5 C 3 13.324219 3.675781 14 4.5 14 L 11.5 14 C '
        '12.324219 14 13 13.324219 13 12.5 L 13 5.292969 L 9.707031 2 Z M 4.5 3 L 9 3 L 9 6 L 12 6 L 12 12.5 C '
        '12 12.78125 11.78125 13 11.5 13 L 4.5 13 C 4.21875 13 4 12.78125 4 12.5 L 4 3.5 C 4 3.21875 4.21875 3 '
        '4.5 3 Z M 10 3.707031 L 11.292969 5 L 10 5 Z M 6 8 L 6 9 L 10 9 L 10 8 Z M 6 10 L 6 11 L 9 11 L 9 10 Z"/></svg>'
    )
    ICON_SVG_FOLDER = (
        '<svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="32px" height="32px">'
        '<path d="M 2.5 2 C 1.675781 2 1 2.675781 1 3.5 L 1 12.5 C 1 13.324219 1.675781 14 2.5 14 L 13.5 14 C 14.324219 '
        '14 15 13.324219 15 12.5 L 15 5.5 C 15 4.675781 14.324219 4 13.5 4 L 6.796875 4 L 6.144531 2.789063 C 5.882813 '
        '2.300781 5.375 2 4.824219 2 Z M 2.5 3 L 4.824219 3 C 5.007813 3 5.175781 3.101563 5.265625 3.261719 L 5.664063 '
        '4 L 2 4 L 2 3.5 C 2 3.21875 2.21875 3 2.5 3 Z M 2 5 L 13.5 5 C 13.78125 5 14 5.21875 14 5.5 L 14 12.5 C 14 12.78125 '
        '13.78125 13 13.5 13 L 2.5 13 C 2.21875 13 2 12.78125 2 12.5 Z"/></svg>'
    )

    EL_REGEX_TAG = re.compile(r'^[^.#]*')
    EL_REGEX_IDS = re.compile(r'[#]([^.#]*)')
    EL_REGEX_CLASSES = re.compile(r'[.]([^.#]*)')

    NO_CLOSING_TAGS = {
        'area',
        'base',
        'br',
        'col',
        'command',
        'hr',
        'img',
        'input',
        'keygen',
        'link',
        'meta',
        'param',
        'source',
        'track',
        'wbr',
    }

    NAME_TO_MIMETYPE = {
        'makefile': 'text/plain',
        'dockerfile': 'text/plain',
        '.gitignore': 'text/plain',
        '.bash_profile': 'text/plain',
        '.bash_logout': 'text/plain',
        '.bash_history': 'text/plain',
        '.bashrc': 'text/plain',
        '.zshrc': 'text/plain',
        '.vimrc': 'text/plain',
        '.history': 'text/plain',
        '.zsh_history': 'text/plain',
    }

    EXT_TO_MIMETYPE = {
        'md': 'text/plain',
        'sh': 'text/plain',
        'conf': 'text/plain',
        'xml': 'text/plain',
        'plist': 'text/plain',
        'pem': 'text/plain',
        'yml': 'text/plain',
        'yaml': 'text/plain',
        'rb': 'text/plain',
        'rs': 'text/plain',
        'toml': 'text/plain',
        'ini': 'text/plain',
        'log': 'text/plain',
        'php': 'text/plain',
    }


class EntryType(enum.Enum):
    UNKNOWN = 0
    FILE = 1
    DIRECTORY = 2


class Entry(NamedTuple):
    name: str
    path: str
    type: EntryType
    readable: bool
    writable: bool
    stat_ctime: float
    stat_mtime: float
    stat_atime: float
    stat_size: int


class ListDirHTML:
    @classmethod
    def __generate_breakcrumbs(cls, webpath: str):
        href_tokens = []
        breadcrumb_elments = [el('a', {'href': '/'}, 'Home')]
        for token in filter(len, webpath.split('/')):
            href_tokens.append(token)
            href = ''.join(('/' + token) for token in href_tokens)
            element = el('a', dict(href=href), token)
            breadcrumb_elments.append(element)
        return breadcrumb_elments

    @classmethod
    def __generate_icon_by_type(cls, type: EntryType) -> str:
        svg = None
        if type == EntryType.FILE:
            svg = Constant.ICON_SVG_DOCUMENT
        elif type == EntryType.DIRECTORY:
            svg = Constant.ICON_SVG_FOLDER
        attrs = {'style': 'width: 16px'}
        if svg is None:
            attrs['alt'] = 'unknown file type'
        else:
            src = Constant.SVG_DATA_URI_PREFIX
            src += MiscUtil.base64_encode(svg)
            attrs['src'] = src
        return el('img', attrs)

    @classmethod
    def generate(cls,
                 webpath: str,
                 entries: List[Entry],
                 allow_modify: bool,
                 folder_writable: bool) -> str:

        table_rows = []
        for i, entry in enumerate(entries):
            link_attrs = {}
            if entry.readable:
                link_attrs['href'] = os.path.join(webpath, entry.name)
            if entry.type == EntryType.FILE:
                link_attrs['target'] = '_blank'
            display_name = FormatUtil.entry_name(entry)
            display_size = FormatUtil.entry_size(entry)
            display_perm = FormatUtil.entry_permission(entry)
            display_ctime = FormatUtil.date(entry.stat_ctime)
            display_mtime = FormatUtil.date(entry.stat_mtime)
            display_atime = FormatUtil.date(entry.stat_atime)
            table_rows.append(
                el('tr.table-row', {
                    'id': display_name,
                    'data-sort-type': entry.type,
                    'data-sort-name': display_name,
                    'data-sort-perm': display_perm,
                    'data-sort-ctime': display_ctime,
                    'data-sort-mtime': display_mtime,
                    'data-sort-atime': display_atime,
                    'data-sort-size': '{:016d}'.format(entry.stat_size),
                    'data-sort-order': i,
                }, (
                    el('td.table-cell-checkbox', [
                        el('input.table-row-checkbox', {
                            'type': 'checkbox',
                            'data-entry-name': entry.name,
                        })
                    ]),
                    el('td.table-cell-icon', cls.__generate_icon_by_type(entry.type)),
                    el('td.table-cell-normal', el('a.name', link_attrs, display_name)),
                    el('td.table-cell-normal', display_size),
                    el('td.table-cell-normal', display_perm),
                    el('td.table-cell-normal', display_ctime),
                    el('td.table-cell-normal', display_mtime),
                    el('td.table-cell-normal', display_atime),
                ))
            )
        if len(table_rows) == 0:
            table_rows.append(
                el('tr', [
                    el('td.table-cell-normal', {'colspan': 7}, el('i', 'empty')),
                ])
            )

        if allow_modify:
            modification_buttons = [
                el('button#upload', {'type': 'button'}, 'Upload'), ' ',
                el('button#delete', {'type': 'button'}, 'Delete'), ' ',
                el('button#newfolder', {'type': 'button'}, 'New Folder'),
            ]
        else:
            modification_buttons = [el('span', 'modification is disabled')]

        parent_path = os.path.dirname(webpath)
        onclick_parent_btn = f'location.href = {j(parent_path)}'

        return el('html', [
            el('head', [
                el('title', webpath),
                el('meta', {'charset': 'utf-8'}),
                el('meta', {'name': 'viewport',
                            'content': 'width=device-width, initial-scale=1'}),
                el('style', Constant.STYLE)
            ]),
            el('body', [
                el('.container', [
                    el('.section', [
                        el('h2', '/'.join(cls.__generate_breakcrumbs(webpath))),
                    ]),
                    el('.section', [
                        el('button', {'type': 'button',
                                      'onclick': onclick_parent_btn}, '..'), ' ',
                        el('input.name-filter', {'type': 'text',
                                                 'placeholder': 'RegExp name filter',
                                                 'autofocus': 'true',
                                                 'spellcheck': 'false'}), ' ',
                        *modification_buttons,
                    ]),
                    el('.section', [
                        el('table.table', [
                            el('tr.table-header', [
                                el('td.table-cell-checkbox',
                                    el('input.table-row-checkbox-all', {'type': 'checkbox'})),
                                el('td.table-cell-normal'),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'name'},
                                                              'name')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'size'},
                                                              'size')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'perm'},
                                                              'permission')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'ctime'},
                                                              'created at')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'mtime'},
                                                              'modified at')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'atime'},
                                                              'accessed at')),
                            ]),
                            ''.join(table_rows),
                        ]),
                    ]),
                ]),
                el('script', f'const modifiable = {j(allow_modify)};'),
                el('script', f'const writable = {j(folder_writable)};'),
                el('script', Constant.SCRIPT),
            ]),
        ])


j = json.dumps


def el(name, *args: List[Union[str, list, tuple, dict]], **kwargs) -> str:
    if not kwargs.pop('when', True):
        return ''
    assert len(kwargs) == 0

    attributes = {}
    children_elements = []

    for arg in args:
        if isinstance(arg, (list, tuple)):
            children_elements.extend(arg)
        elif isinstance(arg, dict):
            attributes.update(arg)
        else:
            children_elements.append(str(arg))

    name_tag = re.search(Constant.EL_REGEX_TAG, name).group() or 'div'
    name_ids = re.findall(Constant.EL_REGEX_IDS, name)
    name_classes = re.findall(Constant.EL_REGEX_CLASSES, name)

    classes = attributes.get('class')
    if isinstance(classes, (list, tuple)):
        attributes['class'] = ' '.join(classes)

    if len(name_ids) > 0:
        assert len(name_ids) == 1
        assert attributes.get('id') is None
        attributes['id'] = name_ids[0]

    if len(name_classes) > 0:
        class_value = attributes.get('class')
        if class_value is not None:
            assert isinstance(class_value, str)
            attributes['class'] = ' '.join((class_value, *name_classes))
        else:
            attributes['class'] = ' '.join(name_classes)

    attributes = ''.join(f' {escape(key)}="{escape(value)}"' for key, value in attributes.items())
    children_html = ''.join(map(str, children_elements))

    if name_tag.lower() in Constant.NO_CLOSING_TAGS:
        assert len(children_html) == 0
        return f'<{escape(name_tag)}{attributes}/>'
    else:
        return f'<{escape(name_tag)}{attributes}>{children_html}</{escape(name_tag)}>'


class FormatUtil:
    @classmethod
    def date(cls, timestamp: Union[int, float]):
        assert isinstance(timestamp, (int, float))
        return str(datetime.fromtimestamp(int(timestamp)))

    @classmethod
    def size(cls, size: int) -> str:
        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:
            if abs(size) < 1024.0:
                return f'{size:3.1f}{unit}'
            size /= 1024.0
        return f'{size:.1f}Y'

    @classmethod
    def get_path_type(cls, path) -> EntryType:
        if os.path.exists(path):
            if os.path.isfile(path):
                return EntryType.FILE
            elif os.path.isdir(path):
                return EntryType.DIRECTORY
        return EntryType.UNKNOWN

    @classmethod
    def entry_name(cls, entry: Entry) -> str:
        if entry.type == EntryType.FILE:
            return entry.name
        elif entry.type == EntryType.DIRECTORY:
            return entry.name + '/'
        else:
            return entry.name + '?'

    @classmethod
    def entry_type(cls, entry: Entry) -> str:
        if entry.type == EntryType.DIRECTORY:
            return 'd'
        elif entry.type == EntryType.FILE:
            return 'f'
        else:
            return '?'

    @classmethod
    def entry_permission(cls, entry: Entry) -> str:
        string = ''
        if entry.readable:
            string += 'R'
        if entry.writable:
            string += 'W'
        return string or '-'

    @classmethod
    def entry_size(cls, entry: Entry) -> str:
        if entry.type == EntryType.FILE:
            return FormatUtil.size(entry.stat_size)
        else:
            return '-'


class PathUtil:
    @classmethod
    def sanitize(cls, path: str) -> str:
        path = path.replace('..', '')
        path = path.replace('//', '')
        path = path.lstrip('/')
        return path

    @classmethod
    def get_type(cls, path: str) -> EntryType:
        if os.path.exists(path):
            if os.path.isfile(path):
                return EntryType.FILE
            elif os.path.isdir(path):
                return EntryType.DIRECTORY
        return EntryType.UNKNOWN

    @classmethod
    def get_readibility(cls, path: str) -> bool:
        type = cls.get_type(path)
        if type == EntryType.FILE:
            return os.access(path, os.R_OK)
        elif type == EntryType.DIRECTORY:
            return os.access(path, os.R_OK | os.X_OK)
        return False

    @classmethod
    def get_writability(cls, path: str) -> bool:
        type = cls.get_type(path)
        if type == EntryType.FILE:
            return os.access(path, os.W_OK)
        elif type == EntryType.DIRECTORY:
            return os.access(path, os.W_OK | os.R_OK | os.X_OK)
        return False


class MiscUtil:
    @classmethod
    def base64_encode(cls, s: str) -> str:
        b = s.encode()
        b = base64.b64encode(b)
        s = b.decode()
        return s

    @classmethod
    def base64_url_encode(cls, s: str) -> str:
        b = s.encode()
        b = base64.urlsafe_b64encode(b)
        s = b.decode()
        return s.rstrip('=')

    @classmethod
    def guess_mimetype(cls, path: str) -> str:
        name = os.path.basename(path).lower()
        if not name:
            return
        mimetype = Constant.NAME_TO_MIMETYPE.get(name)
        if mimetype is not None:
            return mimetype
        exts = name.split('.')
        if len(exts) <= 1:
            return
        mimetype = Constant.EXT_TO_MIMETYPE.get(exts[-1])
        if mimetype is not None:
            return mimetype


class Handler:
    def __init__(self, root: str, no_list: bool, no_modify: bool):
        self.abs_root = os.path.abspath(root)
        self.no_list = no_list
        self.no_modify = no_modify

    def __is_browser_request(self) -> bool:
        ua = request.user_agent.string.lower()
        match = re.search(
            r'(chrome|chromium|crios|firefox|fxios|safari|opr\/|edg)', ua)
        return match is not None

    def __abort(self, status: int, message: str):
        if self.__is_browser_request():
            return abort(status, message)
        else:
            return abort(make_response(jsonify(error=message), status))

    def handle(self, path=''):
        if request.method == 'GET':
            return self.__handle_view(path)
        elif request.method == 'POST':
            action = request.form.get('action')
            if action == 'upload':
                return self.__handle_upload(path)
            elif action == 'delete':
                return self.__handle_delete(path)
            elif action == 'new_folder':
                return self.__handle_mkdir(path)
        self.__abort(400, 'unknown action')

    def __handle_view(self, path):
        local_path = self.__get_local_path(path)
        if local_path is None:
            self.__abort(400, 'invalid path')
        if not os.path.exists(local_path):
            self.__abort(404, 'file or directory does not exist')
        elif not PathUtil.get_readibility(local_path):
            self.__abort(403, 'no permission to access this location')
        elif os.path.isfile(local_path):
            return send_file(local_path, mimetype=MiscUtil.guess_mimetype(local_path))
        elif os.path.isdir(local_path):
            if self.no_list:
                self.__abort(403, 'directory listing is forbidden')
            return self.__list_dir(local_path)
        else:
            self.__abort(403, 'firbidden')

    def __handle_delete(self, path):
        if self.no_modify:
            self.__abort(403, 'modification is forbidden')
        entry_names = request.form.getlist('name')
        local_paths = [self.__get_local_path(
            os.path.join(path, name)) for name in entry_names]
        for entry_name, local_path in zip(entry_names, local_paths):
            if local_path is None:
                self.__abort(400, f'invalid path: {entry_name}')
            dirpath = os.path.dirname(local_path)
            if not PathUtil.get_writability(dirpath):
                self.__abort(
                    403, f'no permission to modify the parent directory of {entry_name}')
            if not PathUtil.get_writability(local_path):
                self.__abort(
                    403, f'no permission to delete {entry_name}')
        result = {}
        from os.path import islink, isfile, isdir, join, exists
        for local_path in local_paths:
            if not local_path:
                continue
            if islink(local_path) or isfile(local_path):
                with suppress(OSError):
                    os.remove(local_path)
                continue
            if isdir(local_path):
                for prefix, dirs, files in os.walk(local_path, topdown=False):
                    if not exists(prefix):
                        continue
                    for name in files:
                        file = join(prefix, name)
                        with suppress(OSError):
                            os.remove(file)
                    for name in dirs:
                        dir = join(prefix, name)
                        if islink(dir):
                            with suppress(OSError):
                                os.remove(dir)
                        else:
                            with suppress(OSError):
                                os.removedirs(dir)
                    with suppress(OSError):
                        os.removedirs(prefix)
        for entry_name, local_path in zip(entry_names, local_paths):
            result[entry_name] = not os.path.exists(local_path)
        if not all(result.values()):
            return result
        if self.__is_browser_request():
            return redirect(f'/{path}', 302)
        else:
            return {'deleted': result}

    def __handle_upload(self, path):
        if self.no_modify:
            self.__abort(403, 'modification is forbidden')
        local_path = self.__get_local_path(path)
        if not os.path.isdir(local_path):
            self.__abort(403, 'location is not a directory')
        if 'file' not in request.files:
            self.__abort(400, 'file is not provided')
        result = {}
        for file in request.files.getlist('file'):
            filename = secure_filename(file.filename)
            filepath = os.path.join(local_path, filename)
            try:
                file.save(filepath)
            except PermissionError:
                self.__abort(
                    403, 'no permission to upload to this location')
            result[filename] = True
        if self.__is_browser_request():
            return redirect(f'/{path}#recent', 302)
        else:
            return {'uploaded': result}

    def __handle_mkdir(self, path):
        if self.no_modify:
            self.__abort(403, 'modification is forbidden')
        name = request.form.get('name')
        if not name:
            self.__abort(400, 'name in not provided')
        folder_path = os.path.join(path, name)
        folder_path = self.__get_local_path(folder_path)
        if os.path.exists(folder_path):
            self.__abort(400, 'folder already exists')
        with suppress(OSError):
            os.makedirs(folder_path, exist_ok=True)
        if not os.path.isdir(folder_path):
            self.__abort(500, 'failed to create folder')
        if self.__is_browser_request():
            return redirect(f'/{path}#recent', 302)
        else:
            return {'new_folder': name}

    def __get_local_path(self, path):
        abs_path = os.path.abspath(os.path.join(self.abs_root, path))
        if abs_path.startswith(self.abs_root):
            return abs_path

    def __list_dir(self, abs_dir_path):
        relpath = os.path.relpath(abs_dir_path, self.abs_root)
        webpath = os.path.abspath(os.path.join('/', relpath))

        entries: List[Entry] = []
        for item_name in os.listdir(abs_dir_path):
            item_path = os.path.join(abs_dir_path, item_name)
            with suppress(Exception):
                stat = os.stat(item_path)
                entry = Entry(
                    name=item_name,
                    path=item_path,
                    type=PathUtil.get_type(item_path),
                    readable=PathUtil.get_readibility(item_path),
                    writable=PathUtil.get_writability(item_path),
                    stat_ctime=stat.st_ctime,
                    stat_mtime=stat.st_mtime,
                    stat_atime=stat.st_atime,
                    stat_size=stat.st_size,
                )
                entries.append(entry)
        entries.sort(key=(lambda entry: (-entry.type.value, entry.name)))

        if self.__is_browser_request():
            allow_modify = not self.no_modify
            folder_writable = os.access(abs_dir_path, os.W_OK)
            html = ListDirHTML.generate(webpath, entries, allow_modify, folder_writable)
            return make_response(html)

        elif request.args.get('json') is not None:
            return jsonify([
                {
                    'name': entry.name,
                    'type': FormatUtil.entry_type(entry),
                    'perm': FormatUtil.entry_permission(entry),
                    'size': entry.stat_size,
                } for entry in entries
            ])
        else:
            resp = make_response(''.join((
                '{}\t({} {})\n'.format(
                    FormatUtil.entry_name(entry),
                    FormatUtil.entry_permission(entry),
                    FormatUtil.entry_size(entry),
                )
                for entry in entries
            )))
            resp.mimetype = 'text/plain'
            return resp


def create_flask_app(root: str,
                     basic_auth: Optional[str],
                     no_list: bool,
                     no_modify: bool) -> Flask:
    app = Flask(__name__, static_folder=None)
    handler = Handler(root, no_list, no_modify)
    handle = handler.handle
    if basic_auth:
        auth = HTTPBasicAuth()
        auth.verify_password(lambda u, p: [None, u][f'{u}:{p}' == basic_auth])
        handle = auth.login_required(handle)
    for rule in ('/', '/<path:path>'):
        app.add_url_rule(rule, 'handle', handle, methods=['GET', 'POST'])
    return app


def generate_certificates(host: str, common_name: Optional[str] = None) -> Tuple[str, str]:
    from os.path import isfile, join, expanduser
    try:
        from cryptography.hazmat.primitives import serialization, hashes
        from cryptography.hazmat.primitives.asymmetric import ec
        from cryptography import x509, __version__ as version
        from cryptography.x509.oid import NameOID
    except ImportError as e:
        exit_with_package_import_error(e)

    current_major = int(version.split('.')[0])
    lowest_major = 36
    if current_major < lowest_major:
        print(f'tls: warning: package cryptography v{current_major} is lower than v{lowest_major}')

    def generate_key():
        return ec.generate_private_key(ec.SECP256R1)

    def import_key(path):
        with open(path, 'rb') as f:
            return serialization.load_pem_private_key(f.read(), None)

    def export_key(key, path, passphrase=None):
        if passphrase is None:
            encryption = serialization.NoEncryption()
        else:
            encryption = serialization.BestAvailableEncryption(
                passphrase.encode())
        with open(path, 'wb') as f:
            f.write(key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=encryption,
            ))

    def x509_name(common_name):
        return x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, common_name)])

    def random_id(prefix, length=8):
        possible_bytes = string.ascii_letters + string.digits
        suffix = ''.join(random.choices(possible_bytes, k=length))
        return f'{prefix}{suffix}'

    def certificate_builder(subject_CN, subject_key, issuer_CN, issuer_key, valid_days):
        # https://www.phildev.net/ssl/creating_ca.html
        return (x509.CertificateBuilder()
                .subject_name(x509_name(subject_CN))
                .issuer_name(x509_name(issuer_CN))
                .public_key(subject_key.public_key())
                .serial_number(x509.random_serial_number())
                .not_valid_before(datetime.utcnow())
                .not_valid_after(datetime.utcnow() + timedelta(days=valid_days)))

    def sign_usr_cert_has_san(builder: x509.CertificateBuilder, subject_key, issuer_key, san):
        return (builder
                .add_extension(x509.SubjectAlternativeName(san), critical=False)
                .add_extension(x509.BasicConstraints(False, None), critical=False)
                .add_extension(x509.AuthorityKeyIdentifier.from_issuer_public_key(issuer_key.public_key()), critical=False)
                .add_extension(x509.SubjectKeyIdentifier.from_public_key(subject_key.public_key()), critical=False)
                .sign(issuer_key, hashes.SHA256()))

    def sign_v3_ca(builder: x509.CertificateBuilder, subject_key, issuer_key):
        return (builder
                .add_extension(x509.BasicConstraints(True, None), critical=False)
                .add_extension(x509.AuthorityKeyIdentifier.from_issuer_public_key(issuer_key.public_key()), critical=False)
                .add_extension(x509.SubjectKeyIdentifier.from_public_key(subject_key.public_key()), critical=False)
                .sign(issuer_key, hashes.SHA256()))

    def import_certificate(path):
        with open(path, 'rb') as f:
            return x509.load_pem_x509_certificate(f.read())

    def export_certificate(certificate, path):
        with open(path, 'wb') as f:
            f.write(certificate.public_bytes(serialization.Encoding.PEM))

    cert_cn = 'localhost'
    if common_name is None:
        print(f'tls: warning: you are using default CN {cert_cn!r}')
        print('tls: warning: you can change CN by adding --https-host HOSTNAME')
    else:
        cert_cn = common_name

    webdir_cfg_dir = expanduser('~/.webdir')
    root_ca_dir = join(webdir_cfg_dir, 'root_ca')
    root_ca_cert_path = join(root_ca_dir, 'cert.pem')
    root_ca_key_path = join(root_ca_dir, 'key.pem')
    cert_dir = join(webdir_cfg_dir, 'certs', cert_cn)
    cert_path = join(cert_dir, 'cert.pem')
    key_path = join(cert_dir, 'key.pem')
    fullchain_path = join(cert_dir, 'fullchain.pem')
    is_cert_dirty = False
    os.makedirs(webdir_cfg_dir, exist_ok=True)
    os.makedirs(root_ca_dir, exist_ok=True)
    os.makedirs(cert_dir, exist_ok=True)

    if isfile(root_ca_key_path):
        root_ca_key = import_key(root_ca_key_path)
    else:
        print(f'tls: generating {root_ca_key_path}')
        root_ca_key = generate_key()
        export_key(root_ca_key, root_ca_key_path)
        assert isfile(root_ca_key_path), repr(root_ca_key_path)
        os.chmod(root_ca_key_path, 0o600)
        is_cert_dirty = True

    if not isfile(root_ca_cert_path) or is_cert_dirty:
        print(f'tls: generating {root_ca_cert_path}')
        root_ca_name = random_id('WebDir Root CA - ')
        root_ca_cert = sign_v3_ca(
            certificate_builder(root_ca_name, root_ca_key, root_ca_name, root_ca_key, 9487),
            subject_key=root_ca_key, issuer_key=root_ca_key
        )
        export_certificate(root_ca_cert, root_ca_cert_path)
        assert isfile(root_ca_cert_path), repr(root_ca_cert_path)
        is_cert_dirty = True
    else:
        root_ca_cert = import_certificate(root_ca_cert_path)
        root_ca_cn_attrs = root_ca_cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
        assert len(root_ca_cn_attrs) == 1, repr(root_ca_cn_attrs)
        root_ca_name = root_ca_cn_attrs[0].value

    if isfile(key_path):
        key = import_key(root_ca_key_path)
    else:
        print(f'tls: generating {key_path}')
        key = generate_key()
        export_key(key, key_path)
        assert isfile(key_path), repr(key_path)
        os.chmod(key_path, 0o600)
        is_cert_dirty = True

    if isfile(cert_path):
        cert = import_certificate(cert_path)
        remain = cert.not_valid_after - datetime.utcnow()
        if remain < timedelta(days=365):
            print(f'tls: renewing {cert_path}')
            os.remove(cert_path)

    if not isfile(cert_path) or is_cert_dirty:
        print(f'tls: generating {cert_path}')
        cert = sign_usr_cert_has_san(
            certificate_builder(cert_cn, key, root_ca_name, root_ca_key, 397),
            subject_key=key, issuer_key=root_ca_key, san=[x509.DNSName(cert_cn)],
        )
        export_certificate(cert, cert_path)
        assert isfile(cert_path), repr(cert_path)
        is_cert_dirty = True

    if not isfile(fullchain_path) or is_cert_dirty:
        print(f'tls: generating {fullchain_path}')
        with open(cert_path) as in1, open(root_ca_cert_path) as in2, open(fullchain_path, 'w') as out:
            out.write(in1.read())
            out.write(in2.read())
        assert isfile(fullchain_path), repr(fullchain_path)

    print(f'tls: using fullchain: {fullchain_path}')
    print(f'tls: using key: {key_path}')
    return fullchain_path, key_path


def app():
    return create_flask_app(
        os.environ.get('WEBDIR_ROOT', '.'),
        os.environ.get('WEBDIR_BASIC_AUTH'),
        os.environ.get('WEBDIR_NO_LIST') is not None,
        os.environ.get('WEBDIR_NO_MODIFY') is not None,
    )


def run_with_gunicorn(app: Flask,
                      host: str,
                      port: int,
                      ssl_context: Optional[Tuple[str, str]],
                      workers: int):
    try:
        from gunicorn.app.base import BaseApplication
    except ImportError as e:
        exit_with_package_import_error(e)

    class Application(BaseApplication):
        def __init__(self, app, **options):
            self.options = options
            self.application = app
            super().__init__()

        def load_config(self):
            config = {key: value for key, value in self.options.items()
                      if key in self.cfg.settings and value is not None}
            for key, value in config.items():
                self.cfg.set(key.lower(), value)

        def load(self):
            return self.application

    options = {}
    options['bind'] = '{}:{}'.format(host, port)
    options['workers'] = workers
    if ssl_context is not None:
        assert isinstance(ssl_context, tuple), 'NOT IMPLEMENTED'
        options['certfile'], options['keyfile'] = ssl_context
    Application(app, **options).run()


def main():
    @dataclass
    class Options:
        root: str
        host: str
        port: int
        debug: bool
        https: bool
        https_host: str
        basic_auth: str
        no_list: bool
        no_modify: bool
        workers: int

    def _path_type(path):
        assert os.path.exists(path), f'path {path!r} does not exist'
        return path

    def _parse_args() -> Options:
        parser = ArgumentParser()
        parser.add_argument('root', nargs='?', type=_path_type, default='.',
                            metavar='PATH', help='document root')
        parser.add_argument('--host', type=str,
                            default='0.0.0.0', help='bind host')
        parser.add_argument('--port', type=int, default=9999, help='bind port')
        parser.add_argument('--debug', action='store_true',
                            help='enable Flask debug auto-reload')
        parser.add_argument('--https', action='store_true', help='enable TLS')
        parser.add_argument('--https-host', type=str, metavar='HOST',
                            help='specified hostname for certificate')
        parser.add_argument('--basic-auth', type=str,
                            metavar='<USER:PASS>', help='authentication')
        parser.add_argument('--no-list', '-L', action='store_true',
                            help='disable directory listing')
        parser.add_argument('--no-modify', '-M', action='store_true',
                            help='disable modification feature')
        parser.add_argument('--workers', '-w', type=int, default=1,
                            metavar='N', help='number of workers')
        args = parser.parse_args()
        return Options(**vars(args))

    args = _parse_args()

    basic_auth_show_password = False

    if args.basic_auth is not None:
        BASIC_AUTH_PROMPT = 'PROMPT'
        BASIC_AUTH_RANDOM = 'RANDOM'
        basic_auth_tuple = args.basic_auth.split(':')
        if len(basic_auth_tuple) == 1 and args.basic_auth == BASIC_AUTH_PROMPT:
            import getpass
            username = input('username: ')
            password = getpass.getpass('password: ')
        elif len(basic_auth_tuple) != 2:
            print('error: unexpected --basic-auth value')
            print('usage:')
            print('  --basic-auth username:password')
            print('  --basic-auth PROMPT')
            print('  --basic-auth username:PROMPT')
            print('  --basic-auth username:RANDOM')
            sys.exit(1)
        else:
            if basic_auth_tuple[0] == BASIC_AUTH_PROMPT:
                username = input('username: ')
            else:
                username = basic_auth_tuple[0]
            if basic_auth_tuple[1] == BASIC_AUTH_PROMPT:
                import getpass
                password = getpass.getpass('password: ')
            elif basic_auth_tuple[1] == BASIC_AUTH_RANDOM:
                chars = string.ascii_letters + string.digits
                password = ''.join(random.choices(chars, k=8))
                basic_auth_show_password = True
            else:
                password = basic_auth_tuple[1]
        args.basic_auth = '{}:{}'.format(username, password)

    if args.https_host is not None:
        args.https = True

    print('---')
    print('options:')
    for key, value in vars(args).items():
        if key == 'basic_auth' and value and not basic_auth_show_password:
            value = value.split(':')[0] + ':[redacted]'
        print('  {}: {}'.format(key, j(value)))
    print('---')

    if args.https:
        if args.https_host == 'adhoc':
            ssl_context = 'adhoc'
        else:
            try:
                ssl_context = generate_certificates(args.host, args.https_host)
            except Exception:
                print('error: failed to generate self-signed certificate')
                print(traceback.format_exc())
                print('warning: falling back ssl_context to adhoc')
                ssl_context = 'adhoc'
        if args.https_host:
            prefix = ''
            if args.basic_auth and basic_auth_show_password:
                prefix = args.basic_auth + '@'
            origin = f'https://{prefix}{args.https_host}'
            if args.port != 443:
                origin += f':{args.port}'
            print(f' * Will be running on {origin}')
    else:
        ssl_context = None

    app = create_flask_app(
        args.root,
        args.basic_auth,
        args.no_list,
        args.no_modify,
    )
    if args.debug or ssl_context == 'adhoc':
        print('Starting Flask app...')
        app.run(
            host=args.host,
            port=args.port,
            debug=args.debug,
            threaded=True,
            processes=args.workers,
            ssl_context=ssl_context,
        )
    else:
        print('Starting Flask app using gunicorn...')
        run_with_gunicorn(
            app,
            host=args.host,
            port=args.port,
            ssl_context=ssl_context,
            workers=args.workers,
        )


if __name__ == '__main__':
    main()
