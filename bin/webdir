#!/usr/bin/env python3
# Author: djosix
# License: MIT
# Description: A simple web file manager written in Python using FastAPI

# autopep8 --max-line-length 130 -i `which webdir`

import json
import re
import os
import sys
import random
import string
import enum
import base64
import traceback
import textwrap
import getpass
from datetime import datetime, timedelta, timezone
from typing import NamedTuple, Union, Optional
from argparse import ArgumentParser
from contextlib import suppress
from dataclasses import dataclass
from urllib.parse import quote as urlquote


def exit_with_package_import_error(e: ImportError):
    assert isinstance(e, ImportError)
    REQUIRED_PACKAGES = [
        'fastapi',
        'uvicorn',
        'cryptography',
        'markupsafe',
        'python-multipart'
    ]
    print(traceback.format_exc())
    print('You must install all the required packages:')
    print('  python3 -m pip install {}'.format(' '.join(REQUIRED_PACKAGES)))
    sys.exit(1)


try:
    import uvicorn
    import multipart as _
    from fastapi import FastAPI, HTTPException, Request, Depends
    from fastapi.security import HTTPBasic, HTTPBasicCredentials
    from fastapi.responses import FileResponse, RedirectResponse, JSONResponse, HTMLResponse, PlainTextResponse
    from markupsafe import escape
except ImportError as e:
    exit_with_package_import_error(e)


class Constant:
    STYLE = textwrap.dedent('''
    * {
        font-family: monospace;
    }
    body,div,span,table,tr,tbody,thead,td,th {
        padding: 0px;
        margin: 0px;
        border: 0px;
    }
    .container {
        /*padding-top: 1em;
        padding-left: 1em;
        padding-right: 1em;*/
    }
    .section {
        display: flex;
        overflow-x: auto;
        white-space: nowrap;
        padding-left: 0.7em;
        padding-right: 0.7em;
        padding-bottom: 0.5em;
    }
    .table-header-link {
        font-weight: bold;
        // font-style: italic;
    }
    .table-cell-checkbox {
        padding: 0.25em 0.25em;
    }
    .table-cell-normal {
        padding: 0.25em 0.5em;
    }
    .table-cell-icon {
        padding-left: 0.5em;
    }
    .menu-item {
        display: inline-block;
        margin-right: 0.5em;
    }
    .table-header {
        border-bottom: 1px solid black;
    }
    .table {
        border-collapse: collapse;
        display: block;
        white-space: nowrap;
    }
    .hidden {
        display: none !important;
    }
    .mark {
        background-color: yellow;
    }
    .table-header-link[data-order=desc]::after {
        content: "-";
    }
    .table-header-link[data-order=asc]::after {
        content: "+";
    }
    .table-row:hover {
        background-color: #F0F0F0;
    }
    #message, #message * {
        font-family: sans-serif;
    }
    .h-space {
        display: inline-block;
        margin-right: 5px;
    }
    .menu.section * {
        font-family: sans-serif !important;
    }
    .loader {
        border: 5px solid #f3f3f3;
        border-radius: 50%;
        border-top: 5px solid #3498db;
        width: 28px;
        height: 28px;
        -webkit-animation: spin 2s linear infinite; /* Safari */
        animation: spin 2s linear infinite;
        margin-top: 10px;
        margin-left: auto;
        margin-right: auto;
    }
    @-webkit-keyframes spin {
        0% { -webkit-transform: rotate(0deg); }
        100% { -webkit-transform: rotate(360deg); }
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    ''')

    SCRIPT = textwrap.dedent('''
    function refreshFilterResult(filterRegex) {
        let regex;
        try {
            regex = new RegExp(filterRegex, 'i');
        } catch (e) {
            regex = new RegExp(/.*/);
        }
        document.querySelectorAll('.table-row').forEach(function (el) {
            let entryName = el.getAttribute('data-sort-name');
            if (regex.test(entryName)) {
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        });
    }

    document.querySelector('input.name-filter').addEventListener('input', function (e) {
        e.preventDefault();
        refreshFilterResult(e.target.value);
    });

    function refreshButtons() {
        const checkboxes = [...document.querySelectorAll('input.table-row-checkbox')];
        const selected = checkboxes.filter(el => el.checked);
        const uploadButton = document.querySelector('button#upload');
        const newFolderButton = document.querySelector('button#newfolder');
        const deleteButton = document.querySelector('button#delete');
        const moveButton = document.querySelector('button#move');
        if (!modifiable || selected.length > 1 ||
            (selected.length === 0 && !writable) ||
            (selected.length === 1 && !selected[0].getAttribute('data-entry-perm').includes('W')))
        {
            uploadButton?.setAttribute('disabled', '');
            newFolderButton?.setAttribute('disabled', '');
        } else {
            uploadButton?.removeAttribute('disabled');
            if (selected.length === 1 && selected[0].getAttribute('data-entry-type') !== 'd') {
                newFolderButton?.setAttribute('disabled', '');
            } else {
                newFolderButton?.removeAttribute('disabled');
            }
        }
        if (selected.length > 0 && writable && modifiable) {
            deleteButton?.removeAttribute('disabled');
            moveButton?.removeAttribute('disabled');
        } else {
            deleteButton?.setAttribute('disabled', '');
            moveButton?.setAttribute('disabled', '');
        }
    }

    function refreshCheckboxState(changedCheckBox) {
        let checkboxAll = document.querySelector('input.table-row-checkbox-all');
        let checkboxes = document.querySelectorAll('input.table-row-checkbox');
        if (changedCheckBox === checkboxAll) {
            checkboxes.forEach(function (checkbox) {
                checkbox.checked = checkboxAll.checked;
            });
        } else {
            let allChecked = true;
            for (let checkbox of checkboxes) {
                if (!checkbox.checked) {
                    allChecked = false;
                    break;
                }
            }
            checkboxAll.checked = allChecked;
        }
    }
    
    function showMessage(html, timeout) {
        const key = btoa(html);
        const el = document.querySelector('dialog#message');
        el.innerHTML = html;
        el.setAttribute('x-key', key);
        el.showModal();
        if (timeout) {
            setTimeout(function () {
                if (el.getAttribute('x-key') === key) {
                    el.close();
                }
            }, timeout);
        }
    }

    document.querySelectorAll('input.table-row-checkbox-all,input.table-row-checkbox').forEach(function (checkbox) {
        checkbox.addEventListener('input', function (e) {
            e.preventDefault();
            refreshCheckboxState(e.target);
            refreshButtons();
        });
    });

    function refreshTableRowOrder(criterion, sign) {
        criterion ||= x => x.getAttribute('data-sort-order');
        sign = Math.sign(sign || 1);
        let table = document.querySelector('table.table');
        let rows = [...table.querySelectorAll('.table-row')];
        console.log(rows);
        rows.sort((a, b) => (criterion(a) > criterion(b) ? sign : -sign));
        for (let el of rows) {
            el.remove();
            table.appendChild(el);
        }
    }

    function createUploadForm(action = '') {
        let form = createHiddenForm(action, 'post');
        form.setAttribute('enctype', 'multipart/form-data');

        form.appendChild(createHiddenInput('action', 'upload'));

        const selected = [...document.querySelectorAll('input.table-row-checkbox')].filter(el => el.checked);
        const target = selected.length === 1 ? selected[0].getAttribute('data-entry-name') : '.';
        form.appendChild(createHiddenInput('target', target));

        let file = document.createElement('input');
        file.setAttribute('type', 'file');
        file.setAttribute('name', 'file');
        file.setAttribute('multiple', '');
        file.addEventListener('change', function fileChangeListener(e) {
            e.target.removeEventListener('change', fileChangeListener);
            if (e.target.files.length > 0) {
                submitHiddenForm(form);
                showMessage(
                    '<div >Uploading ' + e.target.files.length + ' file(s)...</div>' +
                    '<div class="loader"></div>');
            }
        });
        form.appendChild(file);

        return { form, file };
    }

    function uploadFiles(action = '') {
        let obj = createUploadForm(action);
        obj.file.click();
    }

    let uploadButton = document.querySelector('button#upload');
    if (uploadButton) {
        uploadButton.addEventListener('click', function (e) {
            uploadFiles();
        });
    }

    document.body.addEventListener('dragover', function (e) {
        e.preventDefault();
    });

    document.body.addEventListener('drop', function(e) {
        e.preventDefault();
        if (!modifiable) {
            alert('Modification is disabled.');
        } else if (!writable) {
            alert('Current directory is not writable.');
        } else {
            let obj = createUploadForm();
            obj.file.files = e.dataTransfer.files;
            obj.file.dispatchEvent(new Event('change'));
        }
    }, true);

    function createHiddenForm(action, method) {
        let form = document.createElement('form');
        form.setAttribute('action', action);
        form.setAttribute('method', method);
        form.style.display = 'none';
        return form;
    }

    function submitHiddenForm(form) {
        document.body.appendChild(form);
        form.submit();
    }

    function createHiddenInput(name, value) {
        let input = document.createElement('input');
        input.setAttribute('type', 'hidden');
        input.setAttribute('name', name);
        input.setAttribute('value', value);
        return input;
    }    

    function deleteFiles(action = '') {
        let form = createHiddenForm(action, 'post');
        form.appendChild(createHiddenInput('action', 'delete'));

        const selected = [...document.querySelectorAll('input.table-row-checkbox')].filter(el => el.checked);
        if (selected.length > 0) {
            if (!confirm('Are you sure to delete these entries?')) {
                return;
            }
        } else if (selected.length == 0) {
            return;
        }
        for (const el of selected) {
            form.appendChild(createHiddenInput('name', el.getAttribute('data-entry-name')));
        }

        submitHiddenForm(form);
    }

    function moveEntries(action = '') {
        const form = createHiddenForm(action, 'post');
        form.appendChild(createHiddenInput('action', 'move'));

        const selected = [...document.querySelectorAll('input.table-row-checkbox')].filter(el => el.checked);
        if (!selected.length) {
            alert('Please select at least one entry to move.');
            return;
        }
        
        for (let el of selected) {
            form.appendChild(createHiddenInput('source', el.getAttribute('data-entry-name')));
        }

        const targetName = prompt('Destination:');
        if (targetName === null) {
            return;
        } else if (!targetName) {
            alert('Please provide a destination name.');
            return;
        }
        form.appendChild(createHiddenInput('target', targetName));

        submitHiddenForm(form);
    }

    function createFolder(action='') {
        let name = prompt('Please specify a folder name:');
        if (!name) {
            return;
        }
        let invalidChars = /[~!@#$%^&\\*\\(\\)\\+\\{\\}\\|:"<>\\?`\\[\\]\\\\=',\\/]/;
        let matchedInvalidChars = invalidChars.exec(name);
        if (matchedInvalidChars) {
            matchedInvalidChars = [...matchedInvalidChars];
            matchedInvalidChars = matchedInvalidChars.map(c => `(${c})`);
            let formatted = matchedInvalidChars.join(', ');
            alert(`Name contains invalid characters: ${formatted}`);
            return;
        }
        let escapedName = CSS.escape(name);

        let form = createHiddenForm(action, 'post');
        form.appendChild(createHiddenInput('action', 'new_folder'));
        form.appendChild(createHiddenInput('name', name));
        const selected = [...document.querySelectorAll('input.table-row-checkbox')].filter(el => el.checked);
        const target = selected.length === 1 ? selected[0].getAttribute('data-entry-name') : '.';
        form.appendChild(createHiddenInput('target', target));
        submitHiddenForm(form);
    }

    let deleteButton = document.querySelector('button#delete');
    if (deleteButton) {
        deleteButton.addEventListener('click', function (e) {
            deleteFiles();
        })
    }

    let moveButton = document.querySelector('button#move');
    if (moveButton) {
        moveButton.addEventListener('click', function (e) {
            moveEntries();
        })
    }

    let newFolderButton = document.querySelector('button#newfolder');
    if (newFolderButton) {
        newFolderButton.addEventListener('click', function (e) {
            createFolder();
        });
    }

    refreshButtons();

    const sortCriteria = {
        name: row => row.getAttribute('data-sort-name'),
        type: row => row.getAttribute('data-sort-type'),
        ctime: row => row.getAttribute('data-sort-ctime'),
        mtime: row => row.getAttribute('data-sort-mtime'),
        atime: row => row.getAttribute('data-sort-atime'),
        size: row => row.getAttribute('data-sort-size'),
        order: row => row.getAttribute('data-sort-order'),
    };

    document.querySelectorAll('.table-header-link').forEach(function (link) {
        link.addEventListener('click', function (e) {
            e.preventDefault();

            document.querySelectorAll('.table-header-link').forEach(function (otherLink) {
                if (link != otherLink) {
                    otherLink.setAttribute('data-order', '');
                }
            });

            let criterionKey = link.getAttribute('data-sort-by');
            let order = link.getAttribute('data-order');
            let criterion;
            let sortSign;

            if (!order) {
                order = 'asc';
                criterion = sortCriteria[criterionKey] || sortCriteria.order;
                sortSign = 1;
            } else if (order === 'asc') {
                order = 'desc';
                criterion = sortCriteria[criterionKey] || sortCriteria.order;
                sortSign = -1;
            } else if (order === 'desc') {
                order = '';
                criterion = sortCriteria.order;
                sortSign = 1;
            }

            console.log(criterion);

            link.setAttribute('data-order', order);
            refreshTableRowOrder(criterion, sortSign);
        });
    });

    if (location.hash.startsWith('#message=')) {
        const encodedMessage = location.hash.substring(9);
        const decodedMessage = decodeURIComponent(encodedMessage);
        showMessage(decodedMessage, 1000);
        location.hash = '';
        history.replaceState(null, '', location.pathname + location.search);
    }
    ''')

    SVG_DATA_URI_PREFIX = 'data:image/svg+xml;base64,'

    ICON_SVG_DOCUMENT = (
        '<svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="32px" height="32px">'
        '<path d="M 4.5 2 C 3.675781 2 3 2.675781 3 3.5 L 3 12.5 C 3 13.324219 3.675781 14 4.5 14 L 11.5 14 C '
        '12.324219 14 13 13.324219 13 12.5 L 13 5.292969 L 9.707031 2 Z M 4.5 3 L 9 3 L 9 6 L 12 6 L 12 12.5 C '
        '12 12.78125 11.78125 13 11.5 13 L 4.5 13 C 4.21875 13 4 12.78125 4 12.5 L 4 3.5 C 4 3.21875 4.21875 3 '
        '4.5 3 Z M 10 3.707031 L 11.292969 5 L 10 5 Z M 6 8 L 6 9 L 10 9 L 10 8 Z M 6 10 L 6 11 L 9 11 L 9 10 Z"/></svg>'
    )
    ICON_SVG_FOLDER = (
        '<svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="32px" height="32px">'
        '<path d="M 2.5 2 C 1.675781 2 1 2.675781 1 3.5 L 1 12.5 C 1 13.324219 1.675781 14 2.5 14 L 13.5 14 C 14.324219 '
        '14 15 13.324219 15 12.5 L 15 5.5 C 15 4.675781 14.324219 4 13.5 4 L 6.796875 4 L 6.144531 2.789063 C 5.882813 '
        '2.300781 5.375 2 4.824219 2 Z M 2.5 3 L 4.824219 3 C 5.007813 3 5.175781 3.101563 5.265625 3.261719 L 5.664063 '
        '4 L 2 4 L 2 3.5 C 2 3.21875 2.21875 3 2.5 3 Z M 2 5 L 13.5 5 C 13.78125 5 14 5.21875 14 5.5 L 14 12.5 C 14 12.78125 '
        '13.78125 13 13.5 13 L 2.5 13 C 2.21875 13 2 12.78125 2 12.5 Z"/></svg>'
    )

    EL_REGEX_TAG = re.compile(r'^[^.#]*')
    EL_REGEX_IDS = re.compile(r'[#]([^.#]*)')
    EL_REGEX_CLASSES = re.compile(r'[.]([^.#]*)')

    NO_CLOSING_TAGS = {
        'area',
        'base',
        'br',
        'col',
        'command',
        'hr',
        'img',
        'input',
        'keygen',
        'link',
        'meta',
        'param',
        'source',
        'track',
        'wbr',
    }

    NAME_TO_MIMETYPE = {
        'makefile': 'text/plain',
        'dockerfile': 'text/plain',
        '.gitignore': 'text/plain',
        '.bash_profile': 'text/plain',
        '.bash_logout': 'text/plain',
        '.bash_history': 'text/plain',
        '.bashrc': 'text/plain',
        '.zshrc': 'text/plain',
        '.vimrc': 'text/plain',
        '.history': 'text/plain',
        '.zsh_history': 'text/plain',
    }

    EXT_TO_MIMETYPE = {
        'md': 'text/plain',
        'sh': 'text/plain',
        'conf': 'text/plain',
        'xml': 'text/plain',
        'plist': 'text/plain',
        'pem': 'text/plain',
        'yml': 'text/plain',
        'yaml': 'text/plain',
        'rb': 'text/plain',
        'rs': 'text/plain',
        'toml': 'text/plain',
        'ini': 'text/plain',
        'log': 'text/plain',
        'php': 'text/plain',
    }

    ENTRY_TYPE_DIRECTORY = 'directory'
    ENTRY_TYPE_FILE = 'file'
    ENTRY_TYPE_UNKNOWN = 'unknown'


class EntryType(enum.Enum):
    UNKNOWN = 0
    FILE = 1
    DIRECTORY = 2


class Entry(NamedTuple):
    name: str
    path: str
    type: EntryType
    readable: bool
    writable: bool
    stat_ctime: float
    stat_mtime: float
    stat_atime: float
    stat_size: int


class ListDirHTML:
    @classmethod
    def __generate_breakcrumbs(cls, webpath: str, base: str):
        href_tokens = []
        breadcrumb_elments = [el('a', {'href': f'{base}/'}, 'Home')]
        for token in filter(len, webpath.split('/')):
            href_tokens.append(token)
            href = base + ''.join(('/' + token) for token in href_tokens)
            element = el('a', dict(href=href), token)
            breadcrumb_elments.append(element)
        return breadcrumb_elments

    @classmethod
    def __generate_icon_by_type(cls, type: EntryType) -> str:
        svg = None
        if type == EntryType.FILE:
            svg = Constant.ICON_SVG_DOCUMENT
        elif type == EntryType.DIRECTORY:
            svg = Constant.ICON_SVG_FOLDER
        attrs = {'style': 'width: 16px'}
        if svg is None:
            attrs['alt'] = 'unknown file type'
        else:
            src = Constant.SVG_DATA_URI_PREFIX
            src += base64_encode(svg)
            attrs['src'] = src
        return el('img', attrs)

    @classmethod
    def generate(cls,
                 webpath: str,
                 base: str,
                 entries: list[Entry],
                 allow_modify: bool,
                 folder_writable: bool) -> str:

        table_rows = []
        for i, entry in enumerate(entries):
            link_attrs = {}
            if entry.readable:
                href = f'{base}{webpath}/{entry.name}'
                if entry.type == EntryType.DIRECTORY:
                    href += '/'
                link_attrs['href'] = href
            if entry.type == EntryType.FILE:
                link_attrs['target'] = '_blank'
            display_name = Format.entry_name(entry)
            display_size = Format.entry_size(entry)
            display_perm = Format.entry_permission(entry)
            display_ctime = Format.date(entry.stat_ctime)
            display_mtime = Format.date(entry.stat_mtime)
            display_atime = Format.date(entry.stat_atime)
            table_rows.append(
                el('tr.table-row', {
                    'id': display_name,
                    'data-sort-type': entry.type,
                    'data-sort-name': display_name,
                    'data-sort-perm': display_perm,
                    'data-sort-ctime': display_ctime,
                    'data-sort-mtime': display_mtime,
                    'data-sort-atime': display_atime,
                    'data-sort-size': '{:016d}'.format(entry.stat_size),
                    'data-sort-order': i,
                }, (
                    el('td.table-cell-checkbox', [
                        el('input.table-row-checkbox', {
                            'type': 'checkbox',
                            'data-entry-name': entry.name,
                            'data-entry-perm': display_perm,
                            'data-entry-type': Format.entry_type(entry),
                        })
                    ]),
                    el('td.table-cell-icon', cls.__generate_icon_by_type(entry.type)),
                    el('td.table-cell-normal', el('a.name', link_attrs, display_name)),
                    el('td.table-cell-normal', display_size),
                    el('td.table-cell-normal', display_perm),
                    el('td.table-cell-normal', display_ctime),
                    el('td.table-cell-normal', display_mtime),
                    el('td.table-cell-normal', display_atime),
                ))
            )
        if len(table_rows) == 0:
            table_rows.append(
                el('tr', [
                    el('td.table-cell-normal', {'colspan': 7}, el('i', 'empty')),
                ])
            )

        if allow_modify:
            modification_buttons = [
                el('button#upload', {'type': 'button'}, 'Upload'),
                el('.h-space'),
                el('button#delete', {'type': 'button'}, 'Delete'),
                el('.h-space'),
                el('button#move', {'type': 'button'}, 'Move'),
                el('.h-space'),
                el('button#newfolder', {'type': 'button'}, 'New Folder'),
            ]
        else:
            modification_buttons = [el('span', 'modification is disabled')]

        parent_path = os.path.dirname(webpath)
        onclick_parent_btn = f'location.href = {j(parent_path)}'

        return el('html', [
            el('head', [
                el('title', webpath),
                el('meta', {'charset': 'utf-8'}),
                el('meta', {'name': 'viewport',
                            'content': 'width=device-width, initial-scale=1'}),
                el('style', Constant.STYLE)
            ]),
            el('body', [
                el('dialog#message'),
                el('.container', [
                    el('.section', [
                        el('h2', '/'.join(cls.__generate_breakcrumbs(webpath, base))),
                    ]),
                    el('.section.menu', [
                        el('button', {'type': 'button',
                                      'onclick': onclick_parent_btn}, '..'),
                        el('.h-space'),
                        el('input.name-filter', {'type': 'text',
                                                 'placeholder': 'RegExp name filter',
                                                 'autofocus': 'true',
                                                 'spellcheck': 'false'}),
                        el('.h-space'),
                        *modification_buttons,
                        el('.h-space'),
                    ]),
                    el('.section', [
                        el('table.table', [
                            el('tr.table-header', [
                                el('td.table-cell-checkbox',
                                    el('input.table-row-checkbox-all', {'type': 'checkbox'})),
                                el('td.table-cell-normal'),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'name'},
                                                              'name')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'size'},
                                                              'size')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'perm'},
                                                              'permission')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'ctime'},
                                                              'created at')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'mtime'},
                                                              'modified at')),
                                el('td.table-cell-normal', el('a.table-header-link',
                                                              {'href': '#', 'data-sort-by': 'atime'},
                                                              'accessed at')),
                            ]),
                            ''.join(table_rows),
                        ]),
                    ]),
                ]),
                el('script', f'const modifiable = {j(allow_modify)};'),
                el('script', f'const writable = {j(folder_writable)};'),
                el('script', Constant.SCRIPT),
            ]),
        ])


j = json.dumps


def el(name, *args: list[Union[str, list, tuple, dict]], **kwargs) -> str:
    if not kwargs.pop('when', True):
        return ''
    assert len(kwargs) == 0

    attributes = {}
    children_elements = []

    for arg in args:
        if isinstance(arg, (list, tuple)):
            children_elements.extend(arg)
        elif isinstance(arg, dict):
            attributes.update(arg)
        else:
            children_elements.append(str(arg))

    name_tag = re.search(Constant.EL_REGEX_TAG, name).group() or 'div'
    name_ids = re.findall(Constant.EL_REGEX_IDS, name)
    name_classes = re.findall(Constant.EL_REGEX_CLASSES, name)

    classes = attributes.get('class')
    if isinstance(classes, (list, tuple)):
        attributes['class'] = ' '.join(classes)

    if len(name_ids) > 0:
        assert len(name_ids) == 1
        assert attributes.get('id') is None
        attributes['id'] = name_ids[0]

    if len(name_classes) > 0:
        class_value = attributes.get('class')
        if class_value is not None:
            assert isinstance(class_value, str)
            attributes['class'] = ' '.join((class_value, *name_classes))
        else:
            attributes['class'] = ' '.join(name_classes)

    attributes = ''.join(f' {escape(key)}="{escape(value)}"' for key, value in attributes.items())
    children_html = ''.join(map(str, children_elements))

    if name_tag.lower() in Constant.NO_CLOSING_TAGS:
        assert len(children_html) == 0
        return f'<{escape(name_tag)}{attributes}/>'
    else:
        return f'<{escape(name_tag)}{attributes}>{children_html}</{escape(name_tag)}>'


class Format:
    @classmethod
    def date(cls, timestamp: Union[int, float]):
        assert isinstance(timestamp, (int, float))
        return str(datetime.fromtimestamp(int(timestamp)))

    @classmethod
    def size(cls, size: int) -> str:
        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:
            if abs(size) < 1024.0:
                return f'{size:3.1f}{unit}'
            size /= 1024.0
        return f'{size:.1f}Y'

    @classmethod
    def get_path_type(cls, path) -> EntryType:
        if os.path.exists(path):
            if os.path.isfile(path):
                return EntryType.FILE
            elif os.path.isdir(path):
                return EntryType.DIRECTORY
        return EntryType.UNKNOWN

    @classmethod
    def entry_name(cls, entry: Entry) -> str:
        if entry.type == EntryType.FILE:
            return entry.name
        elif entry.type == EntryType.DIRECTORY:
            return entry.name + '/'
        else:
            return entry.name + '?'

    @classmethod
    def entry_type(cls, entry: Entry) -> str:
        if entry.type == EntryType.DIRECTORY:
            return 'd'
        elif entry.type == EntryType.FILE:
            return 'f'
        else:
            return '?'

    @classmethod
    def entry_type_full(cls, entry: Entry) -> str:
        if entry.type == EntryType.DIRECTORY:
            return Constant.ENTRY_TYPE_DIRECTORY
        elif entry.type == EntryType.FILE:
            return Constant.ENTRY_TYPE_FILE
        else:
            return Constant.ENTRY_TYPE_UNKNOWN

    @classmethod
    def entry_permission(cls, entry: Entry) -> str:
        string = ''
        if entry.readable:
            string += 'R'
        if entry.writable:
            string += 'W'
        return string or '-'

    @classmethod
    def entry_size(cls, entry: Entry) -> str:
        if entry.type == EntryType.FILE:
            return cls.size(entry.stat_size)
        else:
            return '-'

    @classmethod
    def table(cls, data) -> str:
        col_widths = [max(len(str(item)) for item in column) for column in zip(*data)]

        def format_row(row):
            return ' | '.join(f'{str(item).ljust(col_widths[i])}' for i, item in enumerate(row))
        lines = []
        lines.append(format_row(data[0]))
        lines.append('-+-'.join('-' * width for width in col_widths))
        for row in data[1:]:
            lines.append(format_row(row))
        return '\n'.join(lines)


class Path:
    @classmethod
    def sanitize(cls, path: str) -> str:
        path = path.replace('..', '')
        path = path.replace('//', '')
        path = path.lstrip('/')
        return path

    @classmethod
    def get_type(cls, path: str) -> EntryType:
        if os.path.exists(path):
            if os.path.isfile(path):
                return EntryType.FILE
            elif os.path.isdir(path):
                return EntryType.DIRECTORY
        return EntryType.UNKNOWN

    @classmethod
    def get_readibility(cls, path: str) -> bool:
        type = cls.get_type(path)
        if type == EntryType.FILE:
            return os.access(path, os.R_OK)
        elif type == EntryType.DIRECTORY:
            return os.access(path, os.R_OK | os.X_OK)
        return False

    @classmethod
    def get_writability(cls, path: str) -> bool:
        type = cls.get_type(path)
        if type == EntryType.FILE:
            return os.access(path, os.W_OK)
        elif type == EntryType.DIRECTORY:
            return os.access(path, os.W_OK | os.R_OK | os.X_OK)
        return False


def base64_encode(s: str) -> str:
    b = s.encode()
    b = base64.b64encode(b)
    s = b.decode()
    return s


def guess_mimetype(path: str) -> str:
    name = os.path.basename(path).lower()
    if not name:
        return
    mimetype = Constant.NAME_TO_MIMETYPE.get(name)
    if mimetype is not None:
        return mimetype
    exts = name.split('.')
    if len(exts) <= 1:
        return
    mimetype = Constant.EXT_TO_MIMETYPE.get(exts[-1])
    if mimetype is not None:
        return mimetype


def mkdir_p(path: str, mode: int):
    dirs_to_create = []
    while True:
        if os.path.isdir(path):
            break
        if os.path.exists(path):
            raise FileExistsError(f'cannot create directory on {path}')
        dirs_to_create.append(path)
        path = os.path.split(path)[0]
    dirs_to_create.reverse()
    for dir in dirs_to_create:
        os.mkdir(dir)
        os.chmod(dir, mode)


class Handler:
    def __init__(self, root: str, base_path: str, no_list: bool, no_modify: bool, create_writable: bool, index_file: str):
        self.abs_root = os.path.abspath(root)
        self.base_path = self.__base_path(base_path)
        self.no_list = no_list
        self.no_modify = no_modify
        self.create_writable = create_writable
        self.index_file = index_file

    def __base_path(self, base_path: str) -> str:
        base_path = base_path.strip('/')
        return base_path and '/' + base_path

    def __is_browser(self, request: Request) -> bool:
        ua = request.headers.get('User-Agent', '').lower()
        expr = r'(chrome|chromium|crios|firefox|fxios|safari|opr\/|edg)'
        return re.search(expr, ua) is not None

    def __should_respond_json(self, request: Request) -> bool:
        return request.query_params.get('json') is not None

    def __abort(self, status: int, message: str):
        raise HTTPException(status_code=status, detail=message)

    async def handle(self, request: Request):
        if not request.url.path.startswith(self.base_path + '/'):
            return RedirectResponse(f'{self.base_path}{request.url.path}', status_code=302)
        if request.method == 'GET':
            return await self.__handle_view(request)
        elif request.method == 'POST':
            form = await request.form()
            action = form.get('action')
            if action == 'upload':
                return await self.__handle_upload(request)
            elif action == 'delete':
                return await self.__handle_delete(request)
            elif action == 'new_folder':
                return await self.__handle_mkdir(request)
            elif action == 'move':
                return await self.__handle_move(request)
        self.__abort(400, 'unknown action')

    async def __handle_view(self, request: Request):
        local_path = self.__get_local_path(request.url.path)

        if not os.path.exists(local_path):
            self.__abort(404, 'file or directory does not exist')
        if not Path.get_readibility(local_path):
            self.__abort(403, 'no permission to access this location')

        if os.path.isfile(local_path):
            return await self.__handle_view_file(request, local_path)
        elif os.path.isdir(local_path):
            return await self.__handle_view_dir(request, local_path)
        else:
            self.__abort(403, 'forbidden')

    async def __handle_view_file(self, request: Request, local_path: str):
        if self.__should_respond_json(request):
            with open(local_path, 'rb') as f:
                content = base64.b64encode(f.read()).decode()
            return JSONResponse(content={
                'type': Constant.ENTRY_TYPE_FILE,
                'content': content,
            })

        return FileResponse(local_path, media_type=guess_mimetype(local_path))

    async def __handle_view_dir(self, request: Request, local_path: str):
        if self.index_file:
            index_path = os.path.join(local_path, self.index_file)
            if os.path.exists(index_path):
                return FileResponse(index_path)

        if self.no_list:
            self.__abort(403, 'directory listing is forbidden')

        entries = self.__list_dir(local_path)

        if self.__should_respond_json(request):
            return JSONResponse(content={
                'type': Constant.ENTRY_TYPE_DIRECTORY,
                'entries': [
                    {
                        'name': entry.name,
                        'type': Format.entry_type_full(entry),
                        'permission': Format.entry_permission(entry),
                        'size': entry.stat_size,
                    } for entry in entries
                ]
            })

        if self.__is_browser(request):
            relpath = os.path.relpath(local_path, self.abs_root)
            webpath = os.path.abspath(os.path.join('/', relpath)).rstrip('/')
            allow_modify = not self.no_modify
            folder_writable = os.access(local_path, os.W_OK)
            html = ListDirHTML.generate(webpath, self.base_path, entries, allow_modify, folder_writable)
            return HTMLResponse(content=html)

        return PlainTextResponse(content=Format.table([
            ['name', 'size', 'permission', 'created at', 'modified at', 'accessed at'],
            *[[Format.entry_name(entry),
               Format.entry_size(entry),
               Format.entry_permission(entry),
               Format.date(entry.stat_ctime),
               Format.date(entry.stat_mtime),
               Format.date(entry.stat_atime)] for entry in entries]
        ]))

    async def __handle_delete(self, request: Request):
        if self.no_modify:
            self.__abort(403, 'modification is forbidden')

        entry_names = (await request.form()).getlist('name')
        local_paths = [self.__get_local_path(f'{request.url.path}/{name}') for name in entry_names]

        for entry_name, local_path in zip(entry_names, local_paths):
            if local_path is None:
                self.__abort(400, f'invalid path: {entry_name}')
            dirpath = os.path.dirname(local_path)
            if not Path.get_writability(dirpath):
                self.__abort(403, f'no permission to modify the parent directory of {entry_name}')
            if not Path.get_writability(local_path):
                self.__abort(403, f'no permission to delete {entry_name}')

        result = {}
        for local_path in local_paths:
            if not local_path:
                continue
            if os.path.islink(local_path) or os.path.isfile(local_path):
                with suppress(OSError):
                    os.remove(local_path)
            elif os.path.isdir(local_path):
                for prefix, _, files in os.walk(local_path, topdown=False):
                    for name in files:
                        file = os.path.join(prefix, name)
                        with suppress(OSError):
                            os.remove(file)
                    with suppress(OSError):
                        os.rmdir(prefix)

        for entry_name, local_path in zip(entry_names, local_paths):
            result[entry_name] = not os.path.exists(local_path)

        if self.__is_browser(request):
            message = urlquote(f'Deleted {len(result)} file(s)')
            return RedirectResponse(f'{request.url.path}#message={message}', status_code=302)
        return JSONResponse({'deleted': result})

    async def __handle_upload(self, request: Request):
        if self.no_modify:
            self.__abort(403, 'modification is forbidden')

        local_path = self.__get_local_path(request.url.path)
        if not os.path.isdir(local_path):
            self.__abort(403, 'location is not a directory')

        form = await request.form()

        files = form.getlist('file')
        if not files:
            self.__abort(400, 'file is not provided')

        target = form.get('target')
        if not target:
            self.__abort(400, 'target name is not provided')

        result = {}

        async def save(file, filepath):
            assert not isinstance(file, str)
            assert os.path.abspath(filepath).startswith(local_path)
            try:
                chunk_size = 1024 * 1024
                with open(filepath, 'wb') as dst:
                    while chunk := await file.read(chunk_size):
                        dst.write(chunk)
                os.chmod(filepath, (0o644, 0o666)[self.create_writable])
            except PermissionError:
                self.__abort(403, 'no permission to upload to this location')
            result[file.filename] = True

        target_path = self.__get_local_path(f'{request.url.path}/{target}')
        if os.path.isdir(target_path):
            for file in files:
                await save(file, os.path.join(target_path, file.filename))
        elif len(files) > 1:
            self.__abort(400, 'target is not a directory')
        else:
            await save(files[0], target_path)

        if self.__is_browser(request):
            message = urlquote(f'Uploaded {len(result)} file(s)')
            return RedirectResponse(f'{request.url.path}#message={message}', status_code=302)

        return JSONResponse({'uploaded': result})

    async def __handle_mkdir(self, request: Request):
        if self.no_modify:
            self.__abort(403, 'modification is forbidden')

        name = (await request.form()).get('name')
        if not name:
            self.__abort(400, 'name is not provided')

        target = (await request.form()).get('target')
        if not target:
            self.__abort(400, 'target name is not provided')

        folder_path = self.__get_local_path(f'{request.url.path}/{target}/{name}')
        if os.path.exists(folder_path):
            self.__abort(400, 'folder already exists')

        mkdir_p(folder_path, mode=(0o755, 0o777)[self.create_writable])

        if not os.path.isdir(folder_path):
            self.__abort(500, 'failed to create folder')

        if self.__is_browser(request):
            message = urlquote(f'Created new folder {name}'.encode())
            return RedirectResponse(f'{request.url.path}#message={message}', status_code=302)

        return JSONResponse({'new_folder': name})

    async def __handle_move(self, request: Request):
        if self.no_modify:
            self.__abort(403, 'modification is forbidden')

        sources = (await request.form()).getlist('source')
        if not sources:
            self.__abort(400, 'source name is not provided')

        target = (await request.form()).get('target')
        if not target:
            self.__abort(400, 'target name is not provided')

        source_paths = []
        for source in sources:
            source_path = self.__get_local_path(f'{request.url.path}/{source}')
            if not Path.get_writability(source_path):
                self.__abort(403, 'no permission to move the source location')
            source_paths.append(source_path)

        result = {}

        def move(src, dst):
            try:
                os.rename(src, dst)
            except:
                self.__abort(500, 'failed to move')
            result[src] = dst

        target_path = self.__get_local_path(f'{request.url.path}/{target}')
        if os.path.isdir(target_path):
            for source_path in source_paths:
                move(source_path, os.path.join(target_path, os.path.basename(source_path)))
        elif len(source_paths) > 1:
            self.__abort(400, 'target is not a directory')
        else:
            move(source_paths[0], target_path)

        if self.__is_browser(request):
            message = urlquote(f'Moved {len(result)} item(s)'.encode())
            return RedirectResponse(f'{request.url.path}#message={message}', status_code=302)

        return JSONResponse({'moved': result})

    def __get_local_path(self, path: str):
        path = path.replace('//', '/')
        prefix = self.base_path or '/'
        assert path.startswith(prefix), str((path, prefix))
        abs_path = os.path.abspath(os.path.join(self.abs_root, path[len(prefix):].strip('/')))
        if abs_path.startswith(self.abs_root):
            return abs_path
        self.__abort(400, 'invalid path: {}'.format(path))

    def __list_dir(self, abs_dir_path: str) -> list[Entry]:
        entries: list[Entry] = []
        for item_name in os.listdir(abs_dir_path):
            item_path = os.path.join(abs_dir_path, item_name)
            with suppress(Exception):
                stat = os.stat(item_path)
                entry = Entry(
                    name=item_name,
                    path=item_path,
                    type=Path.get_type(item_path),
                    readable=Path.get_readibility(item_path),
                    writable=Path.get_writability(item_path),
                    stat_ctime=stat.st_ctime,
                    stat_mtime=stat.st_mtime,
                    stat_atime=stat.st_atime,
                    stat_size=stat.st_size,
                )
                entries.append(entry)
        entries.sort(key=(lambda entry: (-entry.type.value, entry.name)))
        return entries


def create_fastapi_app(root: str,
                       base_path: str,
                       basic_auth: Optional[str],
                       no_list: bool,
                       no_modify: bool,
                       create_writable: bool,
                       index_file: str,
                       ) -> FastAPI:
    app = FastAPI()
    handler = Handler(root, base_path, no_list, no_modify, create_writable, index_file)

    route_options = {
        'methods': ['GET', 'POST'],
        'endpoint': handler.handle,
    }

    if basic_auth:
        async def auth(credentials: HTTPBasicCredentials = Depends(HTTPBasic())):
            if not f"{credentials.username}:{credentials.password}" == basic_auth:
                raise HTTPException(status_code=401, detail="Unauthorized")
            return credentials
        route_options['dependencies'] = [Depends(auth)]

    for path in ('/', '{path:path}'):
        app.add_api_route(path, **route_options)

    return app


def generate_certificates(host: str, common_name: Optional[str] = None) -> tuple[str, str]:
    from os.path import isfile, join, expanduser
    try:
        from cryptography.hazmat.primitives import serialization, hashes
        from cryptography.hazmat.primitives.asymmetric import ec
        from cryptography import x509, __version__ as version
        from cryptography.x509.oid import NameOID
    except ImportError as e:
        exit_with_package_import_error(e)

    current_major = int(version.split('.')[0])
    lowest_major = 36
    if current_major < lowest_major:
        print(f'TLS: warning: package cryptography v{current_major} is lower than v{lowest_major}')

    def generate_key():
        return ec.generate_private_key(ec.SECP256R1())

    def import_key(path):
        with open(path, 'rb') as f:
            return serialization.load_pem_private_key(f.read(), None)

    def export_key(key, path, passphrase=None):
        if passphrase is None:
            encryption = serialization.NoEncryption()
        else:
            encryption = serialization.BestAvailableEncryption(
                passphrase.encode())
        with open(path, 'wb') as f:
            f.write(key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=encryption,
            ))

    def x509_name(common_name):
        return x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, common_name)])

    def random_id(prefix, length=8):
        possible_bytes = string.ascii_letters + string.digits
        suffix = ''.join(random.choices(possible_bytes, k=length))
        return f'{prefix}{suffix}'

    def certificate_builder(subject_CN, subject_key, issuer_CN, issuer_key, valid_days):
        # https://www.phildev.net/ssl/creating_ca.html
        return (x509.CertificateBuilder()
                .subject_name(x509_name(subject_CN))
                .issuer_name(x509_name(issuer_CN))
                .public_key(subject_key.public_key())
                .serial_number(x509.random_serial_number())
                .not_valid_before(datetime.now(timezone.utc))
                .not_valid_after(datetime.now(timezone.utc) + timedelta(days=valid_days)))

    def sign_usr_cert_has_san(builder: x509.CertificateBuilder, subject_key, issuer_key, san):
        return (builder
                .add_extension(x509.SubjectAlternativeName(san), critical=False)
                .add_extension(x509.BasicConstraints(False, None), critical=False)
                .add_extension(x509.AuthorityKeyIdentifier.from_issuer_public_key(issuer_key.public_key()), critical=False)
                .add_extension(x509.SubjectKeyIdentifier.from_public_key(subject_key.public_key()), critical=False)
                .sign(issuer_key, hashes.SHA256()))

    def sign_v3_ca(builder: x509.CertificateBuilder, subject_key, issuer_key):
        return (builder
                .add_extension(x509.BasicConstraints(True, None), critical=False)
                .add_extension(x509.AuthorityKeyIdentifier.from_issuer_public_key(issuer_key.public_key()), critical=False)
                .add_extension(x509.SubjectKeyIdentifier.from_public_key(subject_key.public_key()), critical=False)
                .sign(issuer_key, hashes.SHA256()))

    def import_certificate(path):
        with open(path, 'rb') as f:
            return x509.load_pem_x509_certificate(f.read())

    def export_certificate(certificate, path):
        with open(path, 'wb') as f:
            f.write(certificate.public_bytes(serialization.Encoding.PEM))

    cert_cn = 'localhost'
    if common_name is None:
        print(f'TLS: warning: you are using default CN {cert_cn!r}')
        print('TLS: warning: you can change CN by adding --https-host HOSTNAME')
    else:
        cert_cn = common_name

    webdir_cfg_dir = expanduser('~/.webdir')
    root_ca_dir = join(webdir_cfg_dir, 'root_ca')
    root_ca_cert_path = join(root_ca_dir, 'cert.pem')
    root_ca_key_path = join(root_ca_dir, 'key.pem')
    cert_dir = join(webdir_cfg_dir, 'certs', cert_cn)
    cert_path = join(cert_dir, 'cert.pem')
    key_path = join(cert_dir, 'key.pem')
    fullchain_path = join(cert_dir, 'fullchain.pem')
    is_cert_dirty = False
    os.makedirs(webdir_cfg_dir, exist_ok=True)
    os.makedirs(root_ca_dir, exist_ok=True)
    os.makedirs(cert_dir, exist_ok=True)

    if isfile(root_ca_key_path):
        root_ca_key = import_key(root_ca_key_path)
    else:
        print(f'TLS: generating {root_ca_key_path}')
        root_ca_key = generate_key()
        export_key(root_ca_key, root_ca_key_path)
        assert isfile(root_ca_key_path), repr(root_ca_key_path)
        os.chmod(root_ca_key_path, 0o600)
        is_cert_dirty = True

    if not isfile(root_ca_cert_path) or is_cert_dirty:
        print(f'TLS: generating {root_ca_cert_path}')
        root_ca_name = random_id('WebDir Root CA - ')
        root_ca_cert = sign_v3_ca(
            certificate_builder(root_ca_name, root_ca_key, root_ca_name, root_ca_key, 9487),
            subject_key=root_ca_key, issuer_key=root_ca_key
        )
        export_certificate(root_ca_cert, root_ca_cert_path)
        assert isfile(root_ca_cert_path), repr(root_ca_cert_path)
        is_cert_dirty = True
    else:
        root_ca_cert = import_certificate(root_ca_cert_path)
        root_ca_cn_attrs = root_ca_cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME)
        assert len(root_ca_cn_attrs) == 1, repr(root_ca_cn_attrs)
        root_ca_name = root_ca_cn_attrs[0].value

    if isfile(key_path):
        key = import_key(root_ca_key_path)
    else:
        print(f'TLS: generating {key_path}')
        key = generate_key()
        export_key(key, key_path)
        assert isfile(key_path), repr(key_path)
        os.chmod(key_path, 0o600)
        is_cert_dirty = True

    if isfile(cert_path):
        cert = import_certificate(cert_path)
        remain = cert.not_valid_after_utc - datetime.now(timezone.utc)
        if remain < timedelta(days=365):
            print(f'TLS: renewing {cert_path}')
            os.remove(cert_path)

    if not isfile(cert_path) or is_cert_dirty:
        print(f'TLS: generating {cert_path}')
        cert = sign_usr_cert_has_san(
            certificate_builder(cert_cn, key, root_ca_name, root_ca_key, 397),
            subject_key=key, issuer_key=root_ca_key, san=[x509.DNSName(cert_cn)],
        )
        export_certificate(cert, cert_path)
        assert isfile(cert_path), repr(cert_path)
        is_cert_dirty = True

    if not isfile(fullchain_path) or is_cert_dirty:
        print(f'TLS: generating {fullchain_path}')
        with open(cert_path) as in1, open(root_ca_cert_path) as in2, open(fullchain_path, 'w') as out:
            out.write(in1.read())
            out.write(in2.read())
        assert isfile(fullchain_path), repr(fullchain_path)

    print(f'TLS: using fullchain: {fullchain_path}')
    print(f'TLS: using key: {key_path}')
    return fullchain_path, key_path


def app():
    return create_fastapi_app(
        os.environ.get('WEBDIR_ROOT', '.'),
        os.environ.get('WEBDIR_BASIC_AUTH'),
        os.environ.get('WEBDIR_NO_LIST') is not None,
        os.environ.get('WEBDIR_NO_MODIFY') is not None,
    )


def main():
    @dataclass
    class Config:
        root: str
        host: str
        port: int
        https: bool
        https_host: str
        basic_auth: str
        no_list: bool
        no_modify: bool
        workers: int
        create_writable: bool
        base_path: str
        index_file: str

    def _path_type(path):
        assert os.path.exists(path), f'path {path!r} does not exist'
        return path

    def _parse_args() -> Config:
        parser = ArgumentParser()
        parser.add_argument('root', nargs='?', type=_path_type, default='.',
                            metavar='PATH', help='document root')
        parser.add_argument('--host', type=str,
                            default='0.0.0.0', help='bind host')
        parser.add_argument('--port', type=int, default=9999, help='bind port')
        parser.add_argument('--https', action='store_true', help='enable TLS')
        parser.add_argument('--https-host', type=str, metavar='HOST',
                            help='specified hostname for certificate')
        parser.add_argument('--basic-auth', type=str,
                            metavar='<USER:PASS>', help='authentication')
        parser.add_argument('--no-list', '-L', action='store_true',
                            help='disable directory listing')
        parser.add_argument('--no-modify', '-M', action='store_true',
                            help='disable modification feature')
        parser.add_argument('--workers', '-w', type=int, default=8,
                            metavar='N', help='number of workers')
        parser.add_argument('--create-writable', '-W', action='store_true',
                            help='create writable directories and files for others')
        parser.add_argument('--base-path', '-P', type=str, default='/',
                            help='base path for the application')
        parser.add_argument('--index-file', '-I', type=str,
                            help='if a directory is requested, serve the index file by default')
        args = parser.parse_args()
        return Config(**vars(args))

    cfg = _parse_args()

    basic_auth_show_password = False

    if cfg.basic_auth is not None:
        BASIC_AUTH_PROMPT = 'PROMPT'
        BASIC_AUTH_RANDOM = 'RANDOM'
        basic_auth_tuple = cfg.basic_auth.split(':')
        if len(basic_auth_tuple) == 1 and cfg.basic_auth == BASIC_AUTH_PROMPT:
            username = input('username: ')
            password = getpass.getpass('password: ')
        elif len(basic_auth_tuple) != 2:
            print('error: unexpected --basic-auth value')
            print('usage:')
            print('  --basic-auth username:password')
            print('  --basic-auth PROMPT')
            print('  --basic-auth username:PROMPT')
            print('  --basic-auth username:RANDOM')
            sys.exit(1)
        else:
            if basic_auth_tuple[0] == BASIC_AUTH_PROMPT:
                username = input('username: ')
            else:
                username = basic_auth_tuple[0]
            if basic_auth_tuple[1] == BASIC_AUTH_PROMPT:
                password = getpass.getpass('password: ')
            elif basic_auth_tuple[1] == BASIC_AUTH_RANDOM:
                chars = string.ascii_letters + string.digits
                password = ''.join(random.choices(chars, k=8))
                basic_auth_show_password = True
            else:
                password = basic_auth_tuple[1]
        cfg.basic_auth = '{}:{}'.format(username, password)

    if cfg.https_host is not None:
        cfg.https = True

    for key, value in vars(cfg).items():
        if key == 'basic_auth' and value and not basic_auth_show_password:
            value = value.split(':')[0] + ':[redacted]'
        print('CONFIG: {} = {}'.format(key, j(value)))

    uvicorn_kwargs = {
        'app': create_fastapi_app(
            cfg.root,
            cfg.base_path,
            cfg.basic_auth,
            cfg.no_list,
            cfg.no_modify,
            cfg.create_writable,
            cfg.index_file,
        ),
        'host': cfg.host,
        'port': cfg.port,
    }

    if cfg.https:
        (
            uvicorn_kwargs['ssl_certfile'],
            uvicorn_kwargs['ssl_keyfile'],
        ) = generate_certificates(cfg.host, cfg.https_host)

    uvicorn.run(**uvicorn_kwargs)


if __name__ == '__main__':
    main()
